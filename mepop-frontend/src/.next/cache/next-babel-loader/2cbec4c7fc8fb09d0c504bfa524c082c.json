{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { readString } from 'react-papaparse';\nimport currency from 'currency.js';\nimport moment from 'moment';\nimport { headers } from '../assets/exampleBuyers'; // Reads CSV Content\n\nexport var processFiles = function processFiles(files, setState, err) {\n  if (!files.length) return;\n  var results = []; // Parses CSV content into arrays using readCSVString\n\n  files.forEach(function (file) {\n    readCSVString(file.content, function (res) {\n      results = [].concat(_toConsumableArray(results), _toConsumableArray(res));\n    }, err);\n  }); // initState takes array of CSV data and formats everything for the app\n\n  return initState(results, err);\n};\n\nvar readCSVString = function readCSVString(CSVcontent, results, err) {\n  if (readString(CSVcontent).errors.length) {\n    err();\n  } else {\n    results(readString(CSVcontent).data);\n  }\n}; // Initialized data format that we'll throw into our app's state\n\n\nexport var initState = function initState(originalFiles, err) {\n  var cleanedFiles = _toConsumableArray(originalFiles);\n\n  for (var i = 0; i < cleanedFiles.length; i++) {\n    var row = cleanedFiles[i];\n\n    if (row.length !== 22) {\n      cleanedFiles.splice(i, 1);\n      i--;\n    }\n  }\n\n  var files = cleanAndSort(cleanedFiles);\n  var sorted = sort(files);\n  return setUpState(sorted);\n};\nexport var setUpState = function setUpState(files, currencyType) {\n  var data = {};\n  data.sales = files;\n  data.total_earnings = 0;\n  data.total_shipping_cost = 0;\n  data.depop_fees = 0;\n  data.paypal_fees = 0;\n  data.avg_price = 0;\n  data.avg_shipping = 0;\n  data.avg_total = 0;\n  data.avg_time_listed = 0;\n  data.free_shipping = 0;\n  data.currency_type = currencyType || files[0].item_price[0];\n  files.forEach(function (file) {\n    var miliSeconds = new Date(moment(file.date_of_sale, 'MM-DD-YYYY').format()).getTime() - new Date(moment(file.date_of_listing, 'MM-DD-YYYY').format()).getTime();\n    data.avg_price += currency(file.item_price).value;\n    data.avg_shipping += currency(file.buyer_shipping_cost).value;\n    data.avg_total += currency(file.total).value;\n    data.total_earnings += currency(file.total).value;\n    data.total_shipping_cost += currency(file.buyer_shipping_cost).value + currency(file.usps_cost).value;\n    data.depop_fees += parseFloat(currency(file.depop_fee).value) + parseFloat(currency(file.depop_payments_fee).value);\n    data.avg_time_listed += miliSeconds / (1000 * 3600 * 24);\n\n    if (currency(file.buyer_shipping_cost).value === 0) {\n      data.free_shipping++;\n    }\n\n    if (file.payment_type === 'PAYPAL') {\n      // paypal fees are 2.9% + $0.30\n      data.paypal_fees += 0.029 * currency(file.item_price).value + 0.30;\n    }\n  });\n  data.avg_time_listed = parseInt(data.avg_time_listed / files.length);\n  data.avg_price = parseFloat(data.avg_price / files.length).toFixed(2);\n  data.avg_shipping = parseFloat(data.avg_shipping / files.length).toFixed(2);\n  data.avg_total = parseFloat(data.avg_total / files.length).toFixed(2);\n  data.total_earnings = parseFloat(data.total_earnings).toFixed(2);\n  data.total_shipping_cost = parseFloat(data.total_shipping_cost).toFixed(2);\n  data.depop_fees = parseFloat(data.depop_fees).toFixed(2);\n  data.paypal_fees = parseFloat(data.paypal_fees).toFixed(2);\n\n  data.getUrl = function (slug) {\n    return \"https://www.depop.com/\".concat(slug, \"/\");\n  };\n\n  return data;\n}; // Util function that cleans up format and sorts our files\n\nvar cleanAndSort = function cleanAndSort(originalFiles) {\n  // gets rid of header row\n  var filesToMap = originalFiles.slice().filter(function (row) {\n    return row[0] !== headers[0];\n  });\n  var newFiles = []; // get's rid of duplicates and converts arrays to objects\n\n  filesToMap.forEach(function (row, i) {\n    var item = {}; // this loops through the first file to get headers\n\n    originalFiles[0].forEach(function (key, i) {\n      var keyStr = key.toLowerCase().replace(/ /g, '_');\n\n      var val = function val() {\n        if (keyStr === 'date_of_sale' || keyStr === 'date_of_listing') {\n          // converts UTC to local time\n          var utc = moment.utc(\"\".concat(row[i], \" \").concat(row[1]), 'DD-MM-YYYY h:mm A').format();\n          return moment.utc(utc).local().format('MM-DD-YYYY');\n        } else if (keyStr === 'time_of_sale') {\n          var _utc = moment.utc(\"\".concat(row[0], \" \").concat(row[i]), 'DD-MM-YYYY h:mm A').format();\n\n          return moment.utc(_utc).local().format('hh:mm A');\n        }\n\n        return row[i];\n      };\n\n      item[keyStr] = val();\n    });\n    var existsAlready = newFiles.find(function (e) {\n      return JSON.stringify(e) === JSON.stringify(item);\n    });\n\n    if (!existsAlready) {\n      newFiles.push(item);\n    }\n  });\n  return newFiles;\n};\n\nvar sort = function sort(sales) {\n  // Sorts by date\n  var sorted = sales.sort(function (a, b) {\n    var fullDateA = new Date(moment(\"\".concat(a.date_of_sale, \" \").concat(a.time_of_sale), 'MM-DD-YYYY hh:mm A').format());\n    var fullDateB = new Date(moment(\"\".concat(b.date_of_sale, \" \").concat(b.time_of_sale), 'MM-DD-YYYY hh:mm A').format());\n    return fullDateA - fullDateB;\n  });\n  return sorted;\n};","map":null,"metadata":{},"sourceType":"module"}